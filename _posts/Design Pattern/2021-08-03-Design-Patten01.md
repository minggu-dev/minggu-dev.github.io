---
layout: post
title:  "[Design Pattern] 디자인 패턴(1) - 디자인 패턴 소개"
date:   2021-08-03 10:00:18 +0900
categories: Design-Patten
tags: Design-Patten software
---
# Introduction
<hr>

![패턴](/img/design/pattern01.jpg)
>
#### 개발자가 되기위해 공부를 하면서 누구나 한번쯤은 `디자인 패턴`이라는 용어에 대해 들어본 경험이 있을 것이다. 나도 디자인 패턴에 대해 들어본적이 있지만 따로 공부를 해본적은 없었고 왜 자주 듣게 되는지 어떻게 쓰이는지에 대해 궁금했기 때문에 이글을 통해 디자인 패턴에 대하여 알아보고 간략하게 소개하는 글을 작성해 보고자 한다.

<br>
<br>

# 디자인 패턴이란?
<hr>

디자인 패턴은 개발을 하는데 있어서 자주 발생하는 반복되는 상황에서 설계를 용이하게 하여 좋은 코드를 작성하기 위한 방법이다.

여기서 말하는 좋은 코드란 설계적 관점으로 봤을 때의 좋은 코드를 뜻하는 것으로 코드의 간결함이나 가독성이 아니라 확장과 수정이 용이하고 유지보수에 비용이 적게 들어가는 코드를 뜻한다.

이러한 좋은 코드를 설계하기 위해서 지켜야하는 원칙이 있는데 객체 지향 방법론에서는 이러한 원칙을 SOLID원칙이라고 한다. SOLID원칙에 기반하여 코드 설계 패턴의 종류가 몇 가지로 나눠지는데 이러한 패턴을 디자인 패턴이라고 한다.

본격적으로 디자인 패턴을 소개하기 전에 먼저 SOLID원칙에 대해 알아보자.

<br>
<br>

# SOLID원칙 (객체 지향 5대 원칙)
<hr>

SOLID원칙이란 객체 지향 프로그래밍 및 설계의 기본 원칙으로 알려진 SRP(단일 책임 원칙), OCP(개방-폐쇄 원칙), LSP(리스코프 치환 원칙), DIP(의존 역전 원칙), ISP(인터페이스 분리 원칙)의 앞글자만 따온 것이다. 각각의 원칙에 대해 알아보자.
- **SRP(Single Responsiblity Principle, 단일 책임 원칙)**
  - 클래스나 함수는 하나의 책임을 가져야한다.
  - 즉 하나의 클래스나 함수에 많은 기능을 몰아넣지 말라는 뜻이다.
  - 하나의 클래스나 함수가 갖고있는 책임이 많아지면 클래스 내부의 함수끼리 강한 결합을 가지게 될 가능성이 높아지는데 이는 유지보수 비용이 증가하기 때문에 책임을 분리할 필요가 있다고 한다.

- **OCP(Open-Closed Principle, 개방-폐쇄 원칙)**
  - 기존 코드 변경에는 닫혀있고 추가, 확장에는 열려있어야 한다.
  - 기존의 코드를 변경하기보다 추가 확장을 할 수 있도록 설계해야 한다.

- **LSP(Liskov Substitution Principle, 리스코프 치환 원칙)**
  - 자식 클래스는 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다.
  - 자식 클래스가 부모 클래스를 상속받는 것이 올바른지 확인해야한다.
  	- ex)도형에 속하는 직사각형과 사각형의 경우 직사각형이 사각형의 특성을 가지고 있어 상속받을 수 있지만, 원과 사각형의 경우를 보면 원은 각이 존재하지 않기에 사각형을 상속받기 어렵다고 본다.

- **DIP(Dependency Inversion Principle, 의존 역전 원칙)**
  - 의존 관계에 있어서 변화하기 쉬운 것보다 변화하기 어려운 것에 의존해야 한다.
  - 변화하기 쉬운 것 : 구체적인 것들(클래스)
  - 변화하기 어려운 것 : 추상적인 것들(추상 클래스, 인터페이스)
  - 즉 변수 선언할 때 (인터페이스 or 추상클래스) 변수이름 = (클래스) 이런 느낌이 되어야 한다.
  - DIP를 만족하면 *의존성 주입(Dependency Injection) 기술로 유연하게 설계를 할 수 있다.
  - *DI(Dependency Injection) 의존성 주입
  	- 필요한 객체가 있을 때 객체를 직접 생성하지 않고 외부로 부터 필요한 객체를 받아와서 사용한다.
  	- 객체간의 결합도를 줄일 수 있고 코드의 재활용성이 높아진다.
    ![DI](/img/design/DI.png)
    > 인터페이스 타입을 인자로 받게 하여 인자를 넘겨줄 때 필요한 객체를 넘겨준다.

- **ISP(Interface Segregation Principle, 인터페이스 분리 원칙)**
  - 하나의 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
  - 하나의 일반적인(많은 기능을 가진) 인터페이스 보다는, 여러 개의 구체적인 인터페이스가 낫다.

<br>
<br>

# 디자인 패턴의 종류
<hr>

일반적으로 널리 알려져있는 디자인 패턴 분류법으로 **GoF(Gang of Four, 목적과 범위)**의 패턴 분류 방법이 있는데 목적에 따라 분류를 하면 생성, 구조, 행위 패턴으로 나눌 수 있고 범위에 따라 분류하면 패턴을 클래스에 주로 적용하는지, 객체에 주로 적용하는지로 구분할 수 있다.

### 생성 패턴 (Creational Patterns)
- 객체의 생성과 관련된 패턴이다.
- 클래스 정의와 객체의  생성 방식을 구조화, 캡슐화하여 특정 객체가 생성되거나 변경 되어도 프로그램 구조에 영향을 받지 않도록 유연성을 제공한다.
- 종류
  - 싱글톤 (Singleton)
  전역 변수가 아닌 유일한 하나의 객체를 생성한다.
  - 팩토리 메서드 (Factory Methods)
  객체 생성을 팩토리에서 해준다.
  - 추상 팩토리 메서드 (Abstract Factory Methods)
  팩토리 메서드와 비슷하나 좀 더 상위의 팩토리를 통해 구체적인 팩토리를 생성한다.
  - 빌더 (Builder)
  객체 생성에 필요한 인자가 많을 시 빌더 객체를 통해 객체를 생성한다.
  - 프로토 타입 (Prototype)
  인스턴스를 복제하여 새로운 객체를 생성한다.

### 구조 패턴 (Structural Patterns)
- 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴이다.
- 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.
- 종류
	- 어댑터 (Adapter)
  서로 다른 인터페이스를 가진 두 클래스를 어댑터 클래스로 인터페이스를 통일시켜준다.
  - 브리지 (Bridge)
  기능 클래스와 구현 클래스 계층을 분리한다.
  - 컴퍼지트 (Composite)
  단일 객체와 그 객체를 가지는 집합 객체를 트리구조 형태로 만든다.
  - 데코레이터 (Decorator)
  기본 객체에 기능을 추가하기 쉽도록 한다.
  - 퍼사드 (Facade)
  하나의 인터페이스에 연관된 기능을 묶어 하나의 기능을 제공해준다.
  - 플라이웨이트 (Flyweight)
  하나의 인스턴스 객체를 사용해 여러개의 가상 인스턴스 객체를 제공한다.
  - 프록시 (Proxy)
  프록시 객체를 두어 기본 객체에 간단히 접근한다.

### 행위 패턴 (Behavioral Patterns)
- 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴이다.
- 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배를 하는지, 또 그렇게 하면서 객체 사이의 결합도를 최소화하는 것에 중점을 둔다.
- 종류
	- 스트레티지 (Strategy)
  실행 중에 기능을 선택할 수 있게 해준다.
  - 템플릿 메서드 (Template Methods)
  추상 클래스르 두어 뼈대를 만들고 구현 클래스로 구현한다.
  - 옵저버 (Oberver)
  한 객체의 상태 변화에 따라 다른 객체의 상태도 연동된다.
  - 스테이트 (State)
  객체 내부의 상태가 변화함에 따라 객체의 행위를 바꿀 수 있다.
  - 비지터 (Visitor)
  객체의 구조에서 기능을 분리하여 객체의 구조를 수정하지 않고 기능을 추가할 수 있다.
  - 커맨드 (Command)
  사용자의 요청을 객체로 캡슐화 한다.
  - 인터프리터 (Interpreter)
  문장 해석에 사용된다.
  - 이터레이터 (Iterator)
  객체 내부 구현부를 노출하지 않고 집합 객체에 속한 원소들을 접근할 수 있다.
  - 미디에이터 (Mediator)
  서로 다른 타입의 객체를 통신하게 도와준다.
  - 메멘토 (Memento)
  캡슐화를 위반하지 않으면서 객체 내부 상태를 저장한다.
  - 책임 연쇄 (Chain of Responsibility)
  어떤 요청이 들어왔을 때 적절한 객체로 넘겨준다.

<br><br>

# 마무리
<hr>

#### 오늘은 디자인 패턴이란 무엇인지와 그 종류에 대해서 간략하게 알아 보았다. 하나하나 정확히 다루기엔 포스팅이 너무 길어지게 될 것 같아서 이후에 23가지의 디자인 패턴을 하나씩 자세히 알아보는 글을 올려보겠다.


<br>
<br>
<br>
<br>
이제 막 알아가는 단계인 초보이므로 오류나 잘못된 점이 있다면 지적해주시면 감사합니다! 🥰
